---
layout: post
title: Java对象创建过程与垃圾回收机制
description: 关于Java JVM的一些学习笔记
category: blog
---
##一 创建对象的步骤

<ol>
<li>虚拟机遇到一条<B>new</B>指令</li>
<li>检查指令的参数能否在常量池中定位到一个类的符号引用，并检查这个符号引用代表的类是否已被加载、解析和初始化过</li>
<li>若没有，则必须首先执行相应的类加载过程</li>
<li>类加载完成，虚拟机为新生对象分配内存。分配内存相当于从Java堆中划分出一块内存大小确定的块，分两种情况<br>(1)Java堆内存，属于绝对规整的那种。只需指针向空闲空间挪动一段举例即可<br>(2)不规整。空闲区和已分配区交错，需要一张“空闲列表”记录哪些区域是分配了的</li>
<li>虚拟机对对象进行必要的设置。如，这个对象是哪个类的实例，如何才能找到类的元数据信息，对象的哈希码。此步骤为止<font color="blue">虚拟机步骤完成</font></li>
<li><font color="blue">Java程序开始：</font><init>方法还没有执行，所有字段仍然为0，new指令后，执行<init>方法</li>
</ol>
   
![图示1](/images/blog/java-jvm-store-model.png)   

<B>1  程序计数器</B><br>当前线程执行的字节码的行号指示器。自己吗解释器通过改变程序计数器(PC)的值来选取下一条需要执行的字节码指令。分支、循环、跳转、线程回复等基础功能都依赖于它。
&nbsp;&nbsp;&nbsp;&nbsp;例如：Java多线程机制。线程轮流切换，分配CPU执行时间，任一时刻，一个CPU只会执行一条线程指令，每个线程都需要一个独立PC，以保证线程切换后能正确恢复。      
<B>2  虚拟机栈</B><br>四点说明:   
<ul>
  <li>（1） 生命周期随着线程存亡</li>
  <li>（2）Java方法执行的内存模型：每个方法在执行的同时会创建一个线帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。</li>
  <li>（3）每个方法从调用直至执行完成的过程，就对应着一个线帧在虚拟机栈中从入栈到出栈的过程。</li>
  <li>（4）能发生的两类异常:<br>
      &nbsp;&nbsp;&nbsp;&nbsp;I：线程的请求深度大于虚拟机所允许的深度，会抛出StackOverflowError。<br>
      &nbsp;&nbsp;&nbsp;&nbsp;II：虚拟机栈可动态扩展时无法申请到足够的内存，就会抛出OutOfMemoryError。</li>
</ul>   
<B>3 本地方法栈</B><br>作用与虚拟机相同，不同的是虚拟机栈为虚拟机执行Java方法（即字节码）服务，而本地方法栈为虚拟机执行本地方法（Native）服务。       
<B>4 Java堆</B><br>Java Heap是Java虚拟机所管理的内存中最大的一块，是所有线程共享的一块内存区域。在虚拟机启动时创建，此区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。   
说明：<br>
<ul>
   <li>是垃圾收集器管理的主要目标(GC Garbage Collected)。</li>
   <li>可以处于物理上不连续的内存空间中，只要逻辑上连续即可。</li>
</ul>   
<B>5 方法区</B><br>与堆一样，是所有线程共享的内存区域。它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。   
&nbsp;&nbsp;&nbsp;&nbsp;运行时常量池(Runtime Constannt Pool)：是方法区的一部分。Class文件中除了有类的版本、方法、字段、接口等描述信息外，还有一项是常量池，用于存放编译期间生成的各种字面两和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。<br>
&nbsp;&nbsp;&nbsp;&nbsp;运行时常量池相对于class文件常量池的另外一个特征是动态性，Java语言并不要求常量一定是编译器才能产生。运行期间可将新的常量放入池中，比如String的intern()方法就是这种特性的直接应用。
<br>
<B>6 直接内存</B><br>
&nbsp;&nbsp;&nbsp;&nbsp;非虚拟机运行时数据区的一部分，但频繁使用<br>
来源：JDK 1.4之后引入NIO类，引入一种基于通道（Channel）与缓冲区（Buffer）的I/O方式。它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。由于避免在Java堆和Native堆中来回复制数据，在某些场合可显著提高性能。
<br> 
  
##二 Java内存模型与线程      
<B>1 主要目标</B><br>
&nbsp;&nbsp;&nbsp;&nbsp;定义程序各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量的底层细节。注意：<I>此处的主内存、工作内存与上面的Java堆、栈、方法区等不是同一层次的划分，两者没有关系</I>。<br>
<B>2 内存模型与线程的对应关系如下图：</B><br>
![图示2](/images/blog/java-jvm-store-model2.png)   
<B>3 说明</B><br>
 <ul>
   <li>Java内存模型规定所有变量都存储在主内存中，此处主内存仅是虚拟机内存的一部分。</li>
   <li>每个线程还有自己的工作内存（作用类似于处理器告诉缓冲），线程的工作内存保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量。</li>
</ul>


